plugins {
    id 'java'
    id 'application' //为执行gradle run命令必须的插件
}

group 'com.atguigu'
version '1.0-SNAPSHOT'

mainClassName = 'com.atguigu.ApplicationMain' //为执行gradle run命令必须指定的主启动类名

repositories {
    mavenCentral()
}

dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'
}

test {
    useJUnitPlatform()
}

/*
def map = new HashMap<String,Object>();
map.put("action", { println("task...") })

task(map,"task1") {
    // 任务的配置段，这配置阶段执行
    print "这是最简单的任务"
    // 任务的行为，在执行阶段执行，doFirst会在doLast执行之前执行
    doFirst {
        println("task1 do first")
    }

    doLast {
        println("taks1 do last")
    }
}


task1.doFirst {
    println "task1 doFirst outer"
}

task1.doLast {
    println "task1 doLast outer"
}*/



// 2、任务直接的依赖关系设置
// 方式一：参数方式依赖
/*task A {
    doLast {
        println "TaskA.." }
}
task 'B'{
    doLast {
        println "TaskB.." }
}
//参数方式依赖: dependsOn后面用冒号
task 'C'(dependsOn: ['A','B']){
    doLast {
        println "TaskC.." }
}*/


//方式二:内部依赖
//参数方式依赖
/*
task A {
    doLast {
        println "TaskA.."
    }
}
task 'B' {
    doLast {
        println "TaskB.."
    }
}

task 'C' {
//内部依赖：dependsOn后面用 = 号
    dependsOn = [A, B]
    doLast {
        println "TaskC.."
    }
}
*/


// 方式三：外部依赖
/*task A {
    doLast {
        println "TaskA.."
    }
}
task 'B' {
    doLast {
        println "TaskB.."
    }
}

task 'C'{

}

//外部依赖:可变参数,引号可加可不加
C.dependsOn(B,'A')*/

// 方式四跨项目依赖
// 在 subproject01 工程的 build.gradle 文件中定义 task A
// 在 subproject02 工程的 build.gradle 文件中定义 task B dependsOn(":subproject01:A") //依赖根工程下的subject01中的任务A ：跨项目依赖。


// 3、任务的定义方式
// 任务定义方式，总体分为两大类:一种是通过 Project 中的 task()方法,另一种是通过 tasks 对象的 create 或者 register 方法。

//任务名称,闭包都作为参数
/*task('A', {
    println "taskA..."
})

// 闭包作为最后一个参数可以直接从括号中拿出来
task('B') {
    println "taskB..."
}
// groovy语法支持省略方法括号:上面三种本质是一种
task C {
    println "taskC..."
}

def map = new HashMap<String,Object>();
map.put("action",{println("taskD..")})
task(map,"D");

// 使用tasks的create方法创建任务
tasks.create('E'){
    println("taskE...")
}

// 注：register执行的是延迟创建，也即只有当task被需要使用的时候才会被创建。
tasks.register("F"){
    println("taskF...")
}

//①.F是任务名，前面通过具名参数给map的属性赋值,以参数方式指定任务的属性信息
task(group: "atguigu",description: "this is task G","G")
//②.H是任务名，定义任务的同时，在内部直接指定属性信息
task("H") {
    group("atguigu")
    description("this is the task H")
}
//③.Y是任务名，给已有的任务 在外部直接指定属性信息
task "y"{}
y.group="atguigu"*/

//案例：给已有的clean任务重新指定组信息
//clean.group("atguigu")


// 4、任务类型
/*
前面我们定义的 task 都是 DefaultTask 类型的,如果要完成某些具体的操作完全需要我们自己去编写 gradle 脚本，势必有
些麻烦，那有没有一些现成的任务类型可以使用呢？有的，Gradle 官网给出了一些现成的任务类型帮助我们快速完成想
要的任务，我们只需要在创建任务的时候，指定当前任务的类型即可，然后即可使用这种类型中的属性和 API 方法了。
*/
// 在命令行执行 gradle myClean 发现就可以将当前 project 的 build 目录删除
tasks.register('myClean', Delete) {
    delete buildDir
}


def myTask = task MyDefinitionTask(type: CustomerTask)

myTask.doFirst() {
    println "task 执行之前 执行的 doFirst方法"
}
myTask.doLast() {
    println "task 执行之后 执行的 doLast方法"
}

// 自定义任务类型
class CustomerTask extends DefaultTask{
    //@TaskAction表示Task本身要执行的方法
    @TaskAction
    def doSelf() {
        println "Task 自身 在执行的in doSelf"
    }
}

