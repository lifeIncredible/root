buildscript {
    repositories {
        maven {url "$rootDir/lib/release"}
    }
    dependencies {
        classpath "com.atguigu.plugin:library:1.1"
    }
}
plugins {
    id 'java'
    id 'application' //为执行gradle run命令必须的插件
    id 'java-library'
}

group 'com.atguigu'
version '1.0-SNAPSHOT'

//为执行gradle run命令必须指定的主启动类名
mainClassName = 'com.atguigu.ApplicationMain'

repositories {
    // gradle中会按着仓库配置的顺序，从上往下依次去对应的仓库中找所需要的jar包:
    // 如果找到，则停止向下搜索，如果找不到，继续在下面的仓库中查找
    // 指定去本地某个磁盘目录中查找:使用本地file文件协议:一般不用这种方式
    maven { url 'file:///D:/repos/mavenrepos3.5.4'}
    maven { url "$rootDir/lib/release" }
    // 指定去maven的本地仓库查找
    mavenLocal()
    // 指定去maven的私服或者第三方镜像仓库查找
    maven { name "Alibaba" ; url "https://maven.aliyun.com/repository/public" }
    maven { name "Bstek" ; url "https://nexus.bsdn.org/content/groups/public/" }
    // 指定去maven的远程仓库查找:即 https://repo.maven.apache.org/maven2/
    mavenCentral()
    // 去google仓库查找
    google()
}

// ext 配置的是用户自定义属性，而 gradle.properties 中一般定义 系统属性、环境变量、项目属性、JVM 相关配置
// 自定义一个Project的属性
ext.age = 18
// 通过代码块同时自定义多个属性
ext {
    phone = 19292883833
    address="北京尚硅谷"
}
task extCustomProperty {
// 在task中自定义属性
    ext {
        desc = "奥利给"
    }
    doLast {
        println "年龄是：${age}"
        println "电话是：${phone}"
        println "地址是：${address}"
        println "尚硅谷：${desc}"
    }
}

// allprojects 与subprojects 属性使用
/*allprojects {
    tasks.create("hello"){
        task->
            println("project name is $project.name")
    }
}

subprojects {
    tasks.create("hello"){
        print("project name is $project.name")
    }
}

project('subproject01'){
    apply {
        plugins.apply('java')
    }

    dependencies {
        implementation 'org.hibernate:hibernate-core:3.6.3.Final'
    }
}*/

// 设置项目原级
/*sourceSets {
    main {
        // java 代码的目录
        java {
            srcDirs = ['src/atguigu/java']
        }
        // 配置文件的目录
        resources {
            srcDirs = ['src/atguigu/resources']
        }
        // 配置文件在项目构建后存放的目录
        output.resourcesDir = file('out/bin')
        // java代码在项目构建后存放的目录
        java.destinationDirectory.set(file('out/bin'))
    }
}*/


// =====================第一类，脚本插件========================
//apply from:'version.gradle'
//tasks.register('taskVersion') {
//    doLast {
//        println "公司名称为：${company},JDK版本是${cfgs.compileSdkVersion},版本号是${spring.version}"
//    }
//}

// =================第二类，二进制插件（对象插件）之内部插件apply方式==================
/**
 * apply：map具名的参数方式
 * key：plugin  value：插件id、插件的全类名、插件的简类名
 */
// 使用方式1：Map具名参数,全类名
// apply plugin: org.gradle.api.plugins.JavaPlugin
// org.gradle.api.plugins默认导入：使用方式2
// apply plugin: JavaPlugin
// 核心插件，无需事先引入，使用方式3:插件的id
// apply plugin: 'java'



// =================第二类，二进制插件（对象插件）之三方插件传统方式==================
// 1、如果使用老式插件方式 buildscript{}要放在 build.gradle 文件的最前面,而新式 plugins{}没有该限制。
// 2、托管在网站 gradle 插件官网的第三方插件有两种使用方式，一是传统的 buildscript 方式，一种是 plugins DSL方式 。
// Step1：如果是使用第三方发布的二进制插件，一般需要配置对应的仓库和类路径
// 使用传统的应用方式
/*
build {
    ext {
        springBootVersion = "2.7.5"
    }
    repositories {
        mavenLocal()
        mavenCentral(url: 'https://mvnrepository.com/')
    }
    // 此处先引入插件
    dependencies {
        implementation(group: 'org.springframework.boot', name: 'spring-boot-gradle-plugin', version: '2.7.5')
    }
}
*/
// Step2：再应用插件。社区插件,需要事先引入，不必写版本号
// apply plugin: 'org.springframework.boot'

/**
 * 如果是第三方插件已经被托管在 https://plugins.gradle.org/ 网站上，
 * 就可以不用在 buildscript 里配置 classpath依赖了，
 * 直接使用新出的 plugins DSL 的方式引用，案例如下：使用plugins DSL方式
 */
/*
plugins {
    id 'org.springframework.boot' version '2.4.1'
}
*/


// =================第二类，二进制插件（对象插件）之自定义插件==================
//interface GreetingPluginExtension {
//    Property<String> getMessage()
//    Property<String> getGreeter()
//}
//
//class GreetingPlugin implements Plugin<Project> {
//    void apply(Project project) {
//        def extension = project.extensions.create('greeting', GreetingPluginExtension)
//        project.task('hello') {
//            doLast {
//                println "${extension.getMessage().get()} from ${extension.getGreeter().get()}"
//            }
//        }
//    }
//}
//apply plugin: GreetingPlugin
//
//// Configure the extension using a DSL block
//greeting {
//    message = 'Hi'
//    greeter = 'Gradle'
//}



/***
 * 依赖方式：
 *      1、本地依赖：依赖本地的某个jar包，具体可通过 文件集合、文件树的方式指定
 *      2、项目依赖：依赖某个project
 *      3、直接依赖：依赖的类型 依赖的组名 依赖的名称 依赖的版本号
 * 依赖下载：
 *      当执行 build 命令时，gradle 就会去配置的依赖仓库中下载对应的 Jar，并应用到项目中
 */

/*
dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'
    // 本地依赖的方式：文件集合和文件树完成
    implementation files('lib/mysql.jar,lib/log4j.jar')
    implementation fileTree(dir: 'lib', includes: ['*.jar'], excludes: ['*.jar'])
    // 项目依赖
    implementation project('subproject01')
    // 直接依赖
    implementation 'org.springframework.boot:spring-boot-starter-log4j:1.3.8.RELEASE'
    implementation group: 'org.springframework.boot', name: 'spring-boot-starter-log4j', version: ' 1.3.8.RELEASE'
    implementation 'org.hibernate:hibernate-core:3.6.3.Final'
}
*/
dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'
    /*implementation('org.hibernate:hibernate-core:3.6.3.Final') {
        //exclude group:'org.slf4j'
        //exclude group: 'org.slf4j', module: 'slf4j-api'
        transitive(false) // 不建议使用这种方式
    }
    // 强制使用某个版本号，双感叹号（官方推荐）
    implementation 'org.slf4j:slf4j-api:1.4.0!!'
    // 强制使用某个版本号，闭包版本
    implementation('org.slf4j:slf4j-api:1.4.0'){
        version {
            strictly("1.4.0")
        }
    }*/
    // 动态版本声明（不建议）
    // 依赖携带+号而不是具体版本号代表从中央仓库拉取最新版本号
    //implementation 'org.slf4j:slf4j-api:+'
    // 等同于使用+号代替具体版本号
    //implementation 'org.slf4j:slf4j-api:lastest.integration'
}

test {
    useJUnitPlatform()
}

// 下面我们配置，当 Gradle 构建遇到依赖冲突时，就立即构建失败
configurations.configureEach() {
    Configuration configuration ->
        // 当遇到版本冲突时直接构建失败
        configuration.resolutionStrategy.failOnVersionConflict()
}



// =============================TASK 任务操作=======================================
/*
def map = new HashMap<String,Object>();
map.put("action", { println("task...") })

task(map,"task1") {
    // 任务的配置段，这配置阶段执行
    print "这是最简单的任务"
    // 任务的行为，在执行阶段执行，doFirst会在doLast执行之前执行
    doFirst {
        println("task1 do first")
    }

    doLast {
        println("taks1 do last")
    }
}


task1.doFirst {
    println "task1 doFirst outer"
}

task1.doLast {
    println "task1 doLast outer"
}*/



// 2、任务直接的依赖关系设置
// 方式一：参数方式依赖
/*task A {
    doLast {
        println "TaskA.." }
}
task 'B'{
    doLast {
        println "TaskB.." }
}
//参数方式依赖: dependsOn后面用冒号
task 'C'(dependsOn: ['A','B']){
    doLast {
        println "TaskC.." }
}*/


//方式二:内部依赖
//参数方式依赖
/*
task A {
    doLast {
        println "TaskA.."
    }
}
task 'B' {
    doLast {
        println "TaskB.."
    }
}

task 'C' {
//内部依赖：dependsOn后面用 = 号
    dependsOn = [A, B]
    doLast {
        println "TaskC.."
    }
}
*/


// 方式三：外部依赖
/*task A {
    doLast {
        println "TaskA.."
    }
}
task 'B' {
    doLast {
        println "TaskB.."
    }
}

task 'C'{

}

//外部依赖:可变参数,引号可加可不加
C.dependsOn(B,'A')*/

// 方式四跨项目依赖
// 在 subproject01 工程的 build.gradle 文件中定义 task A
// 在 subproject02 工程的 build.gradle 文件中定义 task B dependsOn(":subproject01:A") //依赖根工程下的subject01中的任务A ：跨项目依赖。


// 3、任务的定义方式
// 任务定义方式，总体分为两大类:一种是通过 Project 中的 task()方法,另一种是通过 tasks 对象的 create 或者 register 方法。

//任务名称,闭包都作为参数
/*task('A', {
    println "taskA..."
})

// 闭包作为最后一个参数可以直接从括号中拿出来
task('B') {
    println "taskB..."
}
// groovy语法支持省略方法括号:上面三种本质是一种
task C {
    println "taskC..."
}

def map = new HashMap<String,Object>();
map.put("action",{println("taskD..")})
task(map,"D");

// 使用tasks的create方法创建任务
tasks.create('E'){
    println("taskE...")
}

// 注：register执行的是延迟创建，也即只有当task被需要使用的时候才会被创建。
tasks.register("F"){
    println("taskF...")
}

//①.F是任务名，前面通过具名参数给map的属性赋值,以参数方式指定任务的属性信息
task(group: "atguigu",description: "this is task G","G")
//②.H是任务名，定义任务的同时，在内部直接指定属性信息
task("H") {
    group("atguigu")
    description("this is the task H")
}
//③.Y是任务名，给已有的任务 在外部直接指定属性信息
task "y"{}
y.group="atguigu"*/

//案例：给已有的clean任务重新指定组信息
//clean.group("atguigu")


// 4、任务类型
/*
前面我们定义的 task 都是 DefaultTask 类型的,如果要完成某些具体的操作完全需要我们自己去编写 gradle 脚本，势必有
些麻烦，那有没有一些现成的任务类型可以使用呢？有的，Gradle 官网给出了一些现成的任务类型帮助我们快速完成想
要的任务，我们只需要在创建任务的时候，指定当前任务的类型即可，然后即可使用这种类型中的属性和 API 方法了。
*/
// 在命令行执行 gradle myClean 发现就可以将当前 project 的 build 目录删除
/*tasks.register('myClean', Delete) {
    delete buildDir
}


def myTask = task MyDefinitionTask(type: CustomerTask)

myTask.doFirst() {
    println "task 执行之前 执行的 doFirst方法"
}
myTask.doLast() {
    println "task 执行之后 执行的 doLast方法"
}

// 自定义任务类型
class CustomerTask extends DefaultTask{
    //@TaskAction表示Task本身要执行的方法
    @TaskAction
    def doSelf() {
        println "Task 自身 在执行的in doSelf"
    }
}*/



// 5、任务的动态分配
/*
4.times { counter ->
    tasks.register("task$counter") {
        group("atguigu")
        doLast {
            println "I'm task number $counter"
        }
    }
}
*/

// 6、任务的关闭与开启
// 每个任务都有一个 enabled 默认为的标志 true。将其设置为 false 阻止执行任何任务动作。禁用的任务将标记为“跳过”。
/*task2.enabled(false)
tasks.named('task0'){
    dependsOn('task2','task3')
}*/

// 7、任务的超时
// 在控制台使用: gradle a b 测试会发现执行 a 的时候,由于 a 执行超时，抛出异常，所以没有继续往下执行【b 也没执行】。
// 然后在控制台使用: gradle a b –continue,测试会发现 a 虽然执行失败，但是 b 还是执行了。
/*task a() {
    doLast {
        Thread.sleep(1000)
        println "当前任务a执行了"
    }
    timeout = Duration.ofMillis(500)
}

task b() {
    doLast {
        println "当前任务b执行了"
    }
}*/

// 8、任务的查找
// 常规的任务查找方法有
/*task atguigu {
    doLast {
        println "让天下没有难学的技术：尚硅谷"
    }
}
//根据任务名查找
tasks.findByName("atguigu").doFirst({println "尚硅谷校区1：北京...."})
tasks.getByName("atguigu").doFirst({println "尚硅谷校区2：深圳...."})
// 根据任务路径查找【相对路径】
tasks.findByPath(":atguigu").doFirst({println "尚硅谷校区3：上海...."})
tasks.getByPath(":atguigu").doFirst({println "尚硅谷校区4：武汉...."})*/


// 9、任务的规则
// 当我们执行、依赖一个不存在的任务时，Gradle 会执行失败,报错误信息。
// 那我们能否对其进行改进,当执行一个不存在的任务时，不是报错而是打印提示信息呢？
/*task hello {
    doLast {
        println("hello 尚硅谷的粉丝们")
    }
}
tasks.addRule("尚硅谷的粉丝们") {
    String taskName -> task(taskName) {
        println("$taskName 任务不存在")
    }
}*/

// 10、任务的Only断言
// 断言就是一个条件表达式。Task 有一个 onlyIf 方法。
// 它接受一个闭包作为参数，如果该闭包返回 true 则该任务执行，否则跳过。
// 这有很多用途，比如控制程序哪些情况下打什么包，什么时候执行单元测试，什么情况下执行单元测试的时候不执行网络测试等。
//tasks.register('hi') {
//    doLast {
//        println '你好，尚硅谷的粉丝们'
//    }
//}
//hi.onlyIf {
//    !project.hasProperty('fensi')
//}

// 10、默认任务
// Gradle 允许您定义一个或多个在没有指定其他任务时执行的默认任务。
//defaultTasks 'myDelete', 'myRun'
//tasks.register('myDelete'){
//    doLast {
//        println 'Default Cleaning!'
//    }
//}
//tasks.register('myRun') {
//    doLast {
//        println 'Default Running!'
//    }
//}
//tasks.register('other') {
//    doLast {
//        println "I'm not a default task!"
//    }
//}

// ===========================================文件操作====================================================
// 1、本地文件
// 使用 Project.file(java.lang.Object)方法，
// 通过指定文件的相对路径或绝对路径来对文件的操作,其中相对路径为相对当前project[根 project 或者子 project]的目录。
// 其实使用 Project.file(java.lang.Object)方法创建的 File 对象就是 Java 中的 File 对象，我们可以使用它就像在 Java 中使用一样。

// 使用相对路径
/*
File configFile = file("src/conf.xml")
configFile.createNewFile();

// 使用绝对路径
configFile = file("D:\\conf.xml")
println(configFile.createNewFile())

// 使用一个文件对象
configFile = new File("src/atguigu.xml")
println(configFile.exists())
*/


// 2、文件集合
/*def fileCollection = files('src/text1.xml', 'src/text2.xml', 'src/text3.xml', ['src/text4.xml', 'src/text5.xml'])
fileCollection.forEach {item ->{
    print(item.name)
    item.createNewFile()
}}

// 把文件集合转换为java中的Set类型
//Set set1 = collection.files
Set set2 = fileCollection as Set

// 把文件集合转换为java中的List类型
List list = fileCollection as List
for (item in list) {
    println item.name
}

//添加或者删除一个集合
def union = fileCollection + files('src/test6.txt')
def minus = fileCollection - files('src/test3.txt')
union.forEach(){
    File it -> println it.name
}*/

// 3、文件树
// 文件树是有层级结构的文件集合,一个文件树它可以代表一个目录结构或一 ZIP 压缩包中的内容结构。
// 文件树是从文件集合继承过来的,所以文件树具有文件集合所有的功能。
// 我们可以使用 Project.fileTree(java.util.Map)方法来创建文件树对象，还可以使用过虑条件来包含或排除相关文件。

// 第一种方式:使用路径创建文件树对象，同时指定包含的文件
//def tree = fileTree('src/main').include('**/*.java')

//第二种方式:通过闭包创建文件树:
//tree = fileTree('src/main') {
//    include '**/*.java'
//}
//第三种方式:通过路径和闭包创建文件树：具名参数给map传值
//tree = fileTree(dir: 'src/main', include: '**/*.java')
//tree = fileTree(dir: 'src/main', includes: ['**/*.java', '**/*.xml', '**/*.txt'], exclude: '**/*test*/**')

//遍历文件树的所有文件
//tree.each {
//    File file -> {
//        println ("$file println $file.name")
//    }
//}

// 4、文件拷贝
//tasks.register('copyTest', Copy) {
//    //拷贝src/main/webapp目录下所有的文件
//    from 'src/main/webapp'
//    //拷贝单独的一个文件
//    from 'src/staging/index.html'
//    //从Zip压缩文件中拷贝内容
//    from zipTree('src/main/assets.zip')
//    //拷贝到的目标目录
//    into 'build/explodedWar'
//}

// 在拷贝文件的时候还可以添加过虑条件来指定包含或排除的
//tasks.register('copyTaskWithPatterns', Copy) {
//    from 'src/main/webapp'
//    into 'build/explodedWar'
//    include '**/*.html'
//    include '**/*.jsp'
//    exclude { details ->
//        details.file.name.endsWith('.html')
//    }
//}

// 在拷贝文件的时候还可以对文件进行重命名操作
//tasks.register('rename', Copy) {
//    from 'src/main/webapp' into 'build/explodedWar' // 使用一个闭包方式重命名文件
//    rename { String fileName ->
//        fileName.replace('-staging-', '')
//    }
//}


//tasks.register('copyMethod') {
//    doLast {
//        copy {
//            from 'src/main/webapp'
//            into 'build/explodedWar'
//            include '**/*.html'
//            include '**/*.jsp'
//        }
//        /*copy {
//            //相对路径或者绝对路径
//            from file('src/main/resources/ddd.txt')
//            //file也可以换成new File()
//            into this.buildDir.absolutePath
//        }*/
//    }
//}

// 5、归档文件
// 通常一个项目会有很多的 Jar 包，我们希望把项目打包成一个 WAR，ZIP 或 TAR 包进行发布，
// 这时我们就可以使用Zip，Tar，Jar，War 和 Ear 任务来实现，不过它们的用法都一样。
// 首先，创建一个 Zip 压缩文件,并指定压缩文件名称
//tasks.register('myZip', Zip) {
//    from('src/main')
//    into('build')
//    baseName('myGame')
//}
//println myZip.archiveName

// 使用zipTree
//def zip = zipTree('someFile.zip')
// 使用tarTree
//def tar = tarTree('someFile.tar')