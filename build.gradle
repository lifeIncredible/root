plugins {
    id 'java'
    id 'application' //为执行gradle run命令必须的插件
}

group 'com.atguigu'
version '1.0-SNAPSHOT'

mainClassName = 'com.atguigu.ApplicationMain' //为执行gradle run命令必须指定的主启动类名

repositories {
    mavenCentral()
}

dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'
}

test {
    useJUnitPlatform()
}

// =============================TASK 任务操作=======================================
/*
def map = new HashMap<String,Object>();
map.put("action", { println("task...") })

task(map,"task1") {
    // 任务的配置段，这配置阶段执行
    print "这是最简单的任务"
    // 任务的行为，在执行阶段执行，doFirst会在doLast执行之前执行
    doFirst {
        println("task1 do first")
    }

    doLast {
        println("taks1 do last")
    }
}


task1.doFirst {
    println "task1 doFirst outer"
}

task1.doLast {
    println "task1 doLast outer"
}*/



// 2、任务直接的依赖关系设置
// 方式一：参数方式依赖
/*task A {
    doLast {
        println "TaskA.." }
}
task 'B'{
    doLast {
        println "TaskB.." }
}
//参数方式依赖: dependsOn后面用冒号
task 'C'(dependsOn: ['A','B']){
    doLast {
        println "TaskC.." }
}*/


//方式二:内部依赖
//参数方式依赖
/*
task A {
    doLast {
        println "TaskA.."
    }
}
task 'B' {
    doLast {
        println "TaskB.."
    }
}

task 'C' {
//内部依赖：dependsOn后面用 = 号
    dependsOn = [A, B]
    doLast {
        println "TaskC.."
    }
}
*/


// 方式三：外部依赖
/*task A {
    doLast {
        println "TaskA.."
    }
}
task 'B' {
    doLast {
        println "TaskB.."
    }
}

task 'C'{

}

//外部依赖:可变参数,引号可加可不加
C.dependsOn(B,'A')*/

// 方式四跨项目依赖
// 在 subproject01 工程的 build.gradle 文件中定义 task A
// 在 subproject02 工程的 build.gradle 文件中定义 task B dependsOn(":subproject01:A") //依赖根工程下的subject01中的任务A ：跨项目依赖。


// 3、任务的定义方式
// 任务定义方式，总体分为两大类:一种是通过 Project 中的 task()方法,另一种是通过 tasks 对象的 create 或者 register 方法。

//任务名称,闭包都作为参数
/*task('A', {
    println "taskA..."
})

// 闭包作为最后一个参数可以直接从括号中拿出来
task('B') {
    println "taskB..."
}
// groovy语法支持省略方法括号:上面三种本质是一种
task C {
    println "taskC..."
}

def map = new HashMap<String,Object>();
map.put("action",{println("taskD..")})
task(map,"D");

// 使用tasks的create方法创建任务
tasks.create('E'){
    println("taskE...")
}

// 注：register执行的是延迟创建，也即只有当task被需要使用的时候才会被创建。
tasks.register("F"){
    println("taskF...")
}

//①.F是任务名，前面通过具名参数给map的属性赋值,以参数方式指定任务的属性信息
task(group: "atguigu",description: "this is task G","G")
//②.H是任务名，定义任务的同时，在内部直接指定属性信息
task("H") {
    group("atguigu")
    description("this is the task H")
}
//③.Y是任务名，给已有的任务 在外部直接指定属性信息
task "y"{}
y.group="atguigu"*/

//案例：给已有的clean任务重新指定组信息
//clean.group("atguigu")


// 4、任务类型
/*
前面我们定义的 task 都是 DefaultTask 类型的,如果要完成某些具体的操作完全需要我们自己去编写 gradle 脚本，势必有
些麻烦，那有没有一些现成的任务类型可以使用呢？有的，Gradle 官网给出了一些现成的任务类型帮助我们快速完成想
要的任务，我们只需要在创建任务的时候，指定当前任务的类型即可，然后即可使用这种类型中的属性和 API 方法了。
*/
// 在命令行执行 gradle myClean 发现就可以将当前 project 的 build 目录删除
tasks.register('myClean', Delete) {
    delete buildDir
}


def myTask = task MyDefinitionTask(type: CustomerTask)

myTask.doFirst() {
    println "task 执行之前 执行的 doFirst方法"
}
myTask.doLast() {
    println "task 执行之后 执行的 doLast方法"
}

// 自定义任务类型
class CustomerTask extends DefaultTask{
    //@TaskAction表示Task本身要执行的方法
    @TaskAction
    def doSelf() {
        println "Task 自身 在执行的in doSelf"
    }
}



// 5、任务的动态分配
4.times { counter ->
    tasks.register("task$counter") {
        group("atguigu")
        doLast {
            println "I'm task number $counter"
        }
    }
}

// 6、任务的关闭与开启
// 每个任务都有一个 enabled 默认为的标志 true。将其设置为 false 阻止执行任何任务动作。禁用的任务将标记为“跳过”。
task2.enabled(false)
tasks.named('task0'){
    dependsOn('task2','task3')
}

// 7、任务的超时
// 在控制台使用: gradle a b 测试会发现执行 a 的时候,由于 a 执行超时，抛出异常，所以没有继续往下执行【b 也没执行】。
// 然后在控制台使用: gradle a b –continue,测试会发现 a 虽然执行失败，但是 b 还是执行了。
task a() {
    doLast {
        Thread.sleep(1000)
        println "当前任务a执行了"
    }
    timeout = Duration.ofMillis(500)
}

task b() {
    doLast {
        println "当前任务b执行了"
    }
}

// 8、任务的查找
// 常规的任务查找方法有
task atguigu {
    doLast {
        println "让天下没有难学的技术：尚硅谷"
    }
}
//根据任务名查找
tasks.findByName("atguigu").doFirst({println "尚硅谷校区1：北京...."})
tasks.getByName("atguigu").doFirst({println "尚硅谷校区2：深圳...."})
// 根据任务路径查找【相对路径】
tasks.findByPath(":atguigu").doFirst({println "尚硅谷校区3：上海...."})
tasks.getByPath(":atguigu").doFirst({println "尚硅谷校区4：武汉...."})


// 9、任务的规则
// 当我们执行、依赖一个不存在的任务时，Gradle 会执行失败,报错误信息。
// 那我们能否对其进行改进,当执行一个不存在的任务时，不是报错而是打印提示信息呢？
task hello {
    doLast {
        println("hello 尚硅谷的粉丝们")
    }
}
tasks.addRule("尚硅谷的粉丝们") {
    String taskName -> task(taskName) {
        println("$taskName 任务不存在")
    }
}

// 10、任务的Only断言
// 断言就是一个条件表达式。Task 有一个 onlyIf 方法。
// 它接受一个闭包作为参数，如果该闭包返回 true 则该任务执行，否则跳过。
// 这有很多用途，比如控制程序哪些情况下打什么包，什么时候执行单元测试，什么情况下执行单元测试的时候不执行网络测试等。
task hi {
    doLast {
        println '你好，尚硅谷的粉丝们'
    }
}
hi.onlyIf {
    !project.hasProperty('fensi')
}

// 10、默认任务
// Gradle 允许您定义一个或多个在没有指定其他任务时执行的默认任务。
defaultTasks 'myDelete', 'myRun'
tasks.register('myDelete'){
    doLast {
        println 'Default Cleaning!'
    }
}
tasks.register('myRun') {
    doLast {
        println 'Default Running!'
    }
}
tasks.register('other') {
    doLast {
        println "I'm not a default task!"
    }
}

// ===========================================文件操作====================================================
// 1、本地文件
// 使用 Project.file(java.lang.Object)方法，
// 通过指定文件的相对路径或绝对路径来对文件的操作,其中相对路径为相对当前project[根 project 或者子 project]的目录。
// 其实使用 Project.file(java.lang.Object)方法创建的 File 对象就是 Java 中的 File 对象，我们可以使用它就像在 Java 中使用一样。

// 使用相对路径
/*
File configFile = file("src/conf.xml")
configFile.createNewFile();

// 使用绝对路径
configFile = file("D:\\conf.xml")
println(configFile.createNewFile())

// 使用一个文件对象
configFile = new File("src/atguigu.xml")
println(configFile.exists())
*/


// 2、文件集合
/*def fileCollection = files('src/text1.xml', 'src/text2.xml', 'src/text3.xml', ['src/text4.xml', 'src/text5.xml'])
fileCollection.forEach {item ->{
    print(item.name)
    item.createNewFile()
}}

// 把文件集合转换为java中的Set类型
//Set set1 = collection.files
Set set2 = fileCollection as Set

// 把文件集合转换为java中的List类型
List list = fileCollection as List
for (item in list) {
    println item.name
}

//添加或者删除一个集合
def union = fileCollection + files('src/test6.txt')
def minus = fileCollection - files('src/test3.txt')
union.forEach(){
    File it -> println it.name
}*/

// 3、文件树
// 文件树是有层级结构的文件集合,一个文件树它可以代表一个目录结构或一 ZIP 压缩包中的内容结构。
// 文件树是从文件集合继承过来的,所以文件树具有文件集合所有的功能。
// 我们可以使用 Project.fileTree(java.util.Map)方法来创建文件树对象，还可以使用过虑条件来包含或排除相关文件。

// 第一种方式:使用路径创建文件树对象，同时指定包含的文件
def tree = fileTree('src/main').include('**/*.java')

//第二种方式:通过闭包创建文件树:
tree = fileTree('src/main') {
    include '**/*.java'
}
//第三种方式:通过路径和闭包创建文件树：具名参数给map传值
tree = fileTree(dir: 'src/main', include: '**/*.java')
tree = fileTree(dir: 'src/main', includes: ['**/*.java', '**/*.xml', '**/*.txt'], exclude: '**/*test*/**')

//遍历文件树的所有文件
tree.each {
    File file -> {
        println ("$file println $file.name")
    }
}

// 4、文件拷贝
tasks.register('copyTest', Copy) {
    //拷贝src/main/webapp目录下所有的文件
    from 'src/main/webapp'
    //拷贝单独的一个文件
    from 'src/staging/index.html'
    //从Zip压缩文件中拷贝内容
    from zipTree('src/main/assets.zip')
    //拷贝到的目标目录
    into 'build/explodedWar'
}

// 在拷贝文件的时候还可以添加过虑条件来指定包含或排除的
tasks.register('copyTaskWithPatterns', Copy) {
    from 'src/main/webapp'
    into 'build/explodedWar'
    include '**/*.html'
    include '**/*.jsp'
    exclude { details ->
        details.file.name.endsWith('.html')
    }
}

// 在拷贝文件的时候还可以对文件进行重命名操作
tasks.register('rename', Copy) {
    from 'src/main/webapp' into 'build/explodedWar' // 使用一个闭包方式重命名文件
    rename { String fileName ->
        fileName.replace('-staging-', '')
    }
}


tasks.register('copyMethod') {
    doLast {
        copy {
            from 'src/main/webapp'
            into 'build/explodedWar'
            include '**/*.html'
            include '**/*.jsp'
        }
        /*copy {
            //相对路径或者绝对路径
            from file('src/main/resources/ddd.txt')
            //file也可以换成new File()
            into this.buildDir.absolutePath
        }*/
    }
}
